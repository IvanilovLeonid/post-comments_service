package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"
	"log"
	"social-comments/api/graphql/generated"
	"social-comments/internal/core/domain"
	"strconv"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input domain.CreatePostInput) (*domain.Post, error) {
	req := domain.CreatePostRequest{
		Title:         input.Title,
		Content:       input.Content,
		Author:        input.Author,
		AllowComments: input.AllowComments,
	}

	resp, err := r.PostService.CreatePost(ctx, req)
	if err != nil {
		return nil, r.wrapGQLError(err)
	}

	return &domain.Post{
		ID:            resp.ID,
		CreatedAt:     resp.CreatedAt,
		Title:         resp.Title,
		Author:        resp.Author,
		Content:       resp.Content,
		AllowComments: true,
	}, nil
}

// ID is the resolver for the id field.
func (r *postResolver) ID(ctx context.Context, obj *domain.Post) (string, error) {
	return obj.GetID(), nil
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *domain.Post, first *int, after *string) ([]*domain.Comment, error) {
	limit := 10
	if first != nil {
		limit = *first
	}

	comments, err := r.CommentService.GetCommentsByPostID(ctx, obj.ID, limit, 0)
	if err != nil {
		return nil, r.wrapGQLError(err)
	}

	result := make([]*domain.Comment, len(comments))
	for i := range comments {
		result[i] = &comments[i]
	}
	return result, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, first *int, after *string) (*domain.PostConnection, error) {

	log.Printf("Posts resolver called with first=%d, after=%v", first, after)

	if r.PostService == nil {
		log.Println("PostService is nil!")
		return nil, errors.New("server error")
	}

	limit := 10
	if first != nil && *first > 0 {
		limit = *first
	}

	offset := 0
	if after != nil {
		if parsedOffset, err := strconv.Atoi(*after); err == nil {
			offset = parsedOffset
		}
	}

	// Добавляем принудительное логирование
	fmt.Printf("\n[Resolver] Params: first=%v, after=%v -> limit=%d, offset=%d\n",
		first, after, limit, offset)

	posts, err := r.PostService.GetAllPosts(ctx, limit, offset)
	if err != nil {
		return nil, r.wrapGQLError(err)
	}

	log.Printf("Received %d posts from service", len(posts))

	edges := make([]*domain.PostEdge, len(posts))
	for i, post := range posts {
		edges[i] = &domain.PostEdge{
			Node:   &post,
			Cursor: strconv.Itoa(offset + i + 1), // Следующий курсор
		}
	}

	var endCursor *string
	hasNextPage := len(posts) == limit // Есть следующая страница, если получили столько же постов, сколько запрашивали

	if len(edges) > 0 {
		cursor := edges[len(edges)-1].Cursor
		endCursor = &cursor
	}

	if repo, ok := r.PostService.(interface{ DebugDumpPosts() }); ok {
		repo.DebugDumpPosts()
	}

	return &domain.PostConnection{
		Edges: edges,
		PageInfo: &domain.PageInfo{
			HasNextPage: hasNextPage,
			EndCursor:   endCursor,
		},
	}, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*domain.Post, error) {
	postID, err := strconv.Atoi(id)
	if err != nil {
		return nil, r.wrapGQLError(errors.New("invalid post ID"))
	}
	post, err := r.PostService.GetPostByID(ctx, postID)
	if err != nil {
		return nil, r.wrapGQLError(err)
	}
	return post, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Post returns generated.PostResolver implementation.
func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
